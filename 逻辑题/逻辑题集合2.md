<!--
 * @Description: 
 * @Author: hetengfei
 * @Github: https://github.com/avrinfly
 * @Date: 2020-03-29 23:54:01
 * @LastEditors: hetengfei
 * @LastEditTime: 2020-04-14 23:57:51
 -->
##### 51 简单
```
["1", "2", "3"].map(parseInt); //返回什么？
//结果  [1, NaN, NaN]　　　
//如果想得到[1, 2,3]应该怎么做？
function returnInt(element){
    return parseInt(element,10);
}
["1", "2", "3"].map(returnInt);　　
```
##### 52
```
    true || false && false // true
```
##### 53 中等
```
function test(foo) {
    console.log(foo.n);
    var foo = {n:2};
}
test(foo); // foo is undefined(foo指的是函数调用时传的参数foo)
test({n:1}); // 1  会生成：var foo = 你传的值   变量存在提升，但是如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性
```
##### 54 简单
```
const value = 'Value is' + !!Number(['0']) ? 'hello' : 'undefined'
// 解析 等价于 Value is false ? 'hello' : 'undefined' ===> 'hello'
// 要注意一点， + 的优先级大于 ?
```
##### 55 较难 有些经典
主要考察事件队列及宏任务和微任务
```
const promise1 = new Promise((resolve,reject) => {
    setTimeout(() => {
        resolve('success');
    }, 1000)
});
const promise2 = promise1.then(() => {
    throw new Error('error!!!');
});
console.log('promise1', promise1);
console.log('promise2', promise2);
setTimeout(() => {
    console.log('promise1', promise1);
    console.log('promise2', promise2);
}, 2000)
// 
```
###### 56 简单
```
以下关于元编程的说法错误的是：
A: Reflect用于替代直接调用Object的方法
B: Reflect是一个函数对象，需要使用new操作符
C: Proxy用于自定义的对象的行为，比如修改set和get
D: Symbol、Reflect和Proxy都属于ES6元编程范畴，能“介入”对象的底层操作进行的过程，并加以影响

答案：B。Reflect不是一个函数对象，没有constructor，所以不需要使用new操作符
```