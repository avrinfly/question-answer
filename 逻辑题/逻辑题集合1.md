<!--
 * @Description: 
 * @Author: hetengfei
 * @Github: https://github.com/avrinfly
 * @Date: 2019-08-17 23:54:50
 * @LastEditors: hetengfei
 * @LastEditTime: 2019-08-25 23:57:05
 -->
##### 1. 中等
```
    let f = function g(){
        return 666
    }    
    console.log(typeof g)//undefined
    console.log(typeof g())//报错 g is not fined
    console.log(typeof g,typeof g())//报错 g is not fined
    //思考：如何才能打印出666？
``` 
##### 2. 中等
```
let foo = '1';
let myFunction = {
    foo:'2',
    funSon:function(){
        (function(){
            let foo = '3';
            console.log("foo = "+ this.foo,this);
        }())
    }
}
myFunction.funSon();//foo = undefined window
var foo = '1';
var myFunction = {
    foo:'2',
    funSon:function(){
        (function(){
            var foo = '3';
            console.log("foo = "+ this.foo,this);
        }())
    }
}
// myFunction.funSon()//foo = 1 window
```
##### 3. 中等
```
function C1(name){//此name为形参
    if(name){//不成立，name还为构造函数的远行对象内的name
        this.name = name;
    }
}
function C2(name){
    this.name = name;
}
function C3(name){
    this.name = name || 'John';
}
C1.prototype.name = 'Tom';
C2.prototype.name = 'Tom';
C3.prototype.name = 'Tom';
console.log((new C1().name)+(new C2().name)+(new C3().name)) //Tom   undefined   John
//attention：打印的三个实例对象中传的参数都为空
``` 
##### 4. 难
```
var s = {
    b:30
}
with(s){
    a:20
}
alert(s.a)//undefined
alert(a)//20
//with会创建了一个新的全局的作用域，a会被当做一个全局变量，所以在外部能找到a，但是在s内部是没有a的
//ps：慎用with，以上会看出，会在不经意间，茫然的创建了一个全局变量，造成内存的泄漏。
```
##### 5. 难
```
var A = function(){};
A.prototype = {};
var a = new A();
A.prototype = {};
var b = new A();
console.log(a instanceof A);//false
console.log(b instanceof A);//true
//instanceof 验证实例对象与原型对象的关系
//如下图所示：
```    
![instanceof示意图](https://www.flygoing.cn/images/2018-7-9/sdfdsf.jpg)
##### 6. 难
```
Object.prototype.name = "flyhandsome";
console.log(1.name)//报错
console.log(1..name)//flyhandsome
console.log(Function.name)//Function
/*
js 中 1.1, 1., .1 都是合法的数字. 那么在解析 1.toString 的时候这个 . 
1. ==> new Number()创建的  1..的话就是违法的
到底是属于这个数字还是函数调用呢? 只能是数字, 因为1.合法啊 所以第一个报错了，第二个对了，至于第三个其实上面的name只是迷惑罢了。
Function维护了自己的name 返回函数名字
*/
```
##### 7. 简单
```
var a = [0,1];
a.splice(0,1);
console.log(a)//1
var a = [0,1];
var b = a.splice(0,1);
console.log(b)//0
//一个打印的是原数组的值，一个打印的是切下来的值，splice切割后会改变原数组
```
###### 8.中等
```
if('https://www.flygoing.cn/gift/picture.jpg'.match('.gif')){
    console.log('成功');
}else{
    console.log('失败')
}
//成功
// match()必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。
//String.prototype.match 接受一个正则, 如果不是, 按照 new RegExp(obj) 转化. 所以 . 并不会转义 那么 /gif 就匹配了~
```
##### 9.简单
```
var a = {}
var b = Object.prototype
a.prototype === b //false
Object.getPrototypeOf(a) === b // true
//attention:只有构造函数有prototype属性，对象没有，所以a.prototype是undefined 
//getPrototypeOf返回的是参数的原型(该参数对象内部的prototype)的值
```  
##### 10.中等
```
alert([,,].length)//2或者3
//A.0 B.2 C.3 D.2或3
//attention:正常情况下[,,]会进行初始化，过程如下图。进行求值，所以基本上得到的结论就是按逗号的个数进行计算。所以等于2（ES6的标准也是最后一个已逗号结尾）.但是在IE8以下为[占,占,占]，所以等于3。
```
##### 11.难
```
var a = [0,1,2];
a[10] = 10;
a.filter(function(x){
    return x === undefined
})//C
//A.[undefined*7] B.[empty*7] C.[] D.报错  
//attention:Array.prototype.filter的 polyfill，filter迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下.
//0 in ary; => true
//3 in ary; => false
//10 in ary; => true
//也就是说 从 3 - 9 都是没有初始化的'坑'!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些'坑'的.
```
##### 12.简单
```
var x = [typeof x,typeof y][1]
typeof x;
//string
//attention:typeof xxx 返回的数据类型的值的类型都是string，所以typeof x是string
//例:typeof 666 返回number，此number应该是"number"
```
##### 13.难
```
function f(){
    console.log(this,this.getPrototypeOf)//f f(){console.log(this,this.getPrototypeOf) return f}
    return f
}
console.log(new f() instanceof f);//false 
//当代码 new f()执行时，下面事情将会发生：
//一个新对象被创建。它继承自 f.prototype
// 构造函数 f被执行。执行的时候，相应的传参会被传入，同时上下文( this)会被指定为这个新实例。 new f等同于 new f()，只能用在不传递任何参数的情况。
// 如果构造函数返回了一个“对象”，那么这个对象会取代整个 new出来的结果。如果构造函数没有返回对象，那么 new出来的结果为步骤1创建的对象，
// ps：一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象
// 于是，我们这里的 new f()返回的仍然是函数 f本身，而并非他的实例
```
##### 14 难
```
var arvin = {
    bar:function(){
        console.log(this)//Argument[ƒ, callee: ƒ, Symbol(Symbol.iterator): ƒ]
        return this.baz
    },
    baz:1
};
(function(){
    //架设：arguments.bar = 3
    console.log(typeof arguments[0]())//undefined
})(arvin.bar)

//attention:打印结果中 this指向arguments   arguments[0]()相当于arguments() ==>arvin.bar
//如架设 最后返回结果即为 number
```
##### 15 中等
```
function text(){
    console.log('outer')
}
function qq(){
    // var text
    if(false){
        function text(){
            console.log('inner')
        }
    }
    text()
}
qq()//报错 text is not undefined
//attention：类似于变量提升，text函数名提升，但是函数体并未提升，所以会报错
```